---
title: 高阶函数———柯里化（Currying）
date: 2020-11-11
tags:
 - JavaScript
categories:
 -  JavaScript
---

## 前言

在这之前我们应该清楚什么是高阶函数，通俗的说，函数可以作为参数传递到函数中，这个作为参数的函数叫回调函数，而拥有这个参数的函数就是高阶函数，回调函数在高阶函数中调用并传递相应的参数，在高阶函数执行时，由于回调函数的内部逻辑不同，高阶函数的执行结果也不同，非常灵活，也被叫做函数式编程。我们常常利⽤⾼阶函数来封装⼀些公共的逻辑。

## 柯里化（Currying）

柯里化（Currying）是一种关于函数的高阶技术。它不仅被用于 JavaScript，还被用于其他编程语言。
柯里化是一种函数的转换，它是指将一个函数从可调用的 f(a, b, c) 转换为可调用的 f(a)(b)(c)。
柯里化不会调用函数。它只是对函数进行转换。

让我们先来看一个例子，以更好地理解我们正在讲的内容，然后再进行一个实际应用。

我们将创建一个辅助函数 curry(f)，该函数将对两个参数的函数 f 执行柯里化。换句话说，对于两个参数的函数 f(a, b) 执行 curry(f) 会将其转换为以 f(a)(b) 形式运行的函数：

```javascript
function curry(f) {   // curry(f) 执行柯里化转化
  return function(a) {
    return function(b) {
      return f(a, b)
    }
  }
}

// 用法
function sum(a, b) {
  return a + b
}

let _sum = curry(sum(1))
console.log( _sum(1)(3) ) // 4
console.log( sum(1, 3) ) // 4
```

正如你所看到的，_sum(1)(3)和sum(1, 3)返回的结果是一样的，柯⾥化函数的运⾏过程其实是⼀个参数的收集过程，我们将每⼀次传⼊的参数收集起来，并在最⾥层处理。

柯里化更高级的实现，例如 lodash 库的 _.curry，会返回一个包装器，该包装器允许函数被正常调用或者以偏函数（partial）的方式调用：

```javascript
function sum(a, b) {
  return a + b;
}

let _sum = _.curry(sum); // 使用来自 lodash 库的 _.curry

alert( _sum(1, 3) ); // 4，仍可正常调用
alert( _sum(1)(3) ); // 4，以partial的方式调用
```

## 柯里化？目的是？

仔细的兄弟们可能已经发现，把函数经过 curry 转化为⼀个柯⾥化函数，最后执⾏的结果， 不是正好相当于执⾏函数⾃身吗？柯⾥化是不是把简单的问题复杂化了？柯⾥化确实是把问题复杂化了，但是复杂化的同时，我们在使⽤函数时拥有了更加多的⾃由度。要了解它的好处，我们需要一个实际中的例子。**来！上才艺！！**

我们有一个用于格式化和输出信息的日志（logging）函数 log(date, url, importance, message)。在实际项目中，此类函数具有很多有用的功能，例如通过网络发送日志（log）:

```javascript
function logging(date, url, importance, message) {
  axios.post({ date, url, importance, message})
}
```

对logging进行柯里化！！

```javascript
let _logging = _.curry(logging)

_logging(new Date(), 'https://damohou.github.io/', 'DEBUG', 'some debug message') // 柯里化之后可以正常运行
_logging(new Date())('https://damohou.github.io/')('DEBUG')('some debug message') // 也可以用柯里化的形式运行
```

现在我们可以轻松的为当前函数创建各种便捷函数：

```javascript
// logNow 是带有固定第一个参数的日志的partial函数
let nowLog = _logging(new Date())

// 用法
nowLog('https://damohou.github.io/', 'DEBUG', 'some debug message')
```

我们可以更进一步，为当前的调试日志（debug log）提供便捷函数：

```javascript
let  debugNowLog = nowLog('https://damohou.github.io/', 'DEBUG')

// 用法
debugNowLog('some debug message')
```

## 柯里化的实现

```javascript
function cuury(fun) {
  return function curried(...args) {
    if (args.length >=  fun.length) {
      return fun.apply(this, args)
    } else {
      return function(...args2) {
        return curried.apply(this, [...args, ...args2])
      }
    }
  }
}
```

用法：

```javascript
function sum(a, b, c) {
  return a + b + c
}

let cuuriedSum = curry(sum)
console.log( cuuriedSum(1, 2, 3) ) // 6
console.log( cuuriedSum(1, 2)(3) ) // 6
console.log( cuuriedSum(1)(2)(3) ) // 6
```

当我们运行它时，这里有两个 if 执行分支：
1.现在调用：如果传入的 args 长度与原始函数所定义的（func.length）相同或者更长，那么只需要将调用传递给它即可。
2.获取一个偏函数：否则，func 还没有被调用。取而代之的是，返回另一个带已传入参数的partial函数，它将重新应用 curried，将之前传入的参数与新的参数一起传入。然后，在一个新的调用中，再次，我们将获得一个新的partial函数（如果参数不足的话），或者最终的结果。

让我们看看 sum(a, b, c) 这个例子。它有三个参数，所以 sum.length = 3。

对于调用 curried(1)(2)(3)：

1.第一个调用 curried(1) 将 1 保存在词法环境中，然后返回一个带参数（1）的partial函数。

2.第一步返回的partial函数被调用，参数为 (2)：它会获取之前的参数 (1)，将它与得到的 (2) 连在一起，并一起调用 curried(1, 2)。由于参数数量仍小于 3，curry 函数依然会返回partial函数。

3.第二步返回的partial函数再次被调用，参数为 (3)，在接下来的调用中，它会获取之前的参数 (1, 2) 并将 3 与之合并，执行调用 curried(1, 2, 3)，最终有 3 个参数，它们被传入最原始的函数中。

## 总结

柯里化是一种转换，将 f(a,b,c) 转换为可以被以 f(a)(b)(c) 的形式进行调用。JavaScript 实现通常都保持该函数可以被正常调用，并且如果参数数量不足，则返回偏函数。

柯里化让我们能够更容易地获取偏函数。就像我们在日志记录示例中看到的那样，普通函数 log(date, importance, message) 在被柯里化之后，当我们调用它的时候传入一个参数（如 log(date)）或两个参数（log(date, importance)）时，它会返回偏函数。
